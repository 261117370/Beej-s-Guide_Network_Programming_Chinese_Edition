我尽可能还原作者的语言风格，这也是本指南的一大亮点。

《Beej的指南——网络编程》
1. 序言
    socket编程是不是让你很沮丧？要想从man手册中搞清楚这些是不是有点儿困难？你想做网络编程，但你又没时间去弄清楚一些细节，比如说：是不是该在调用connect()之前调用bind()，等等一些。
    好吧，其实我已经干完这份儿脏活累活（意指作者已经掌握理解网络编程的知识）了，并且我非常非常想和所有人来分析那个这些知识。反正你看这本书就对了。这个指南旨在给有C语言基础的并且想了解网络编程的程序猿阅读。（没一定的C语言知识还是别来了，回去再练练吧）
    请注意，我最终是跟上了未来的脚步，就是说已经更新了IPv6的指南，Enjoy！！！
1.1. 适用人群
    这本书是作为一本自学教程而写的，并不是一本全面的参考手册（参考手册绝对不是一百来页能描述完的）。最适合的读者是那些刚开始接触socket编程并且正在苦苦寻找教程的。总而言之，这不是所谓的完全参考手册。
1.2. 平台和编译器
    这本书中的包含的代码是使用Linux PC平台下的Gnu的gcc编译套件的（为什么描述这么长，如果你不懂为什么，那么又吃亏了）。一般来说，这些代码应该能在任意使用gcc编译套件的平台上编译。如果你给Windows编程的话，很显然，这些代码并不适用，具体你可以看看下面关于Windows编程的那段话。
1.3. 官方主页和购买本书
    唯一官方主页：http://beej.us/guide/bgnet/。
    你不仅可以在官网上找到一些示例代码，而且还可以找到不同语言的翻译版本。（很遗憾，官网上的中文翻译版本的链接貌似失效了，正式因为这样，我才自己动手来翻译，自己动手，丰衣足食嘛）。
    本书也有纸质印刷版，你可以去网站：http://beej.us/guide/url/bgbuy，购买精美的纸质书，如果你买了书，我会很欣赏的，因为你的行为支撑着我写作的生活方式。（我非常推荐大家去买作者的纸质书，貌似大陆现在不能直接买，得从国外买了带回来。我正考虑托朋友从国外买了带过来，其实我也推介作者把自己paypal放出来，大家捐助也是一种帮助的方式）
1.4. 给Solaris/SunOS程序猿的提示
    当你在Solaris/SunOS下编译时，你需要做一些额外的工作才能通过。在链接阶段，需要加上“-lnsl -lsocket -lresolv”，来使得链接器链接上正确的库。举例来说吧：
    $ cc -o server server.c -lnsl -lsocket -lresolv
    如果按照上面提示的做了以后还有错误，你再多加一个“-lxnet”试试看，说实话，我其实也不知道那是在干嘛，但是很多人看起来需要加上这个。
    你还可以在调用setsockopt()的时候发生错误。因为这个函数原型在我的Linux平台和其他Sun平台是不同的，请做这样的替换：
    int yes = 1;
    换成：
    char yes = '1';
    正因为我没有Sun平台的设备，以至于我没有测试过上面所说的。这些问题和解决方法仅仅是其他人们通过邮件告诉我的。（我说老外就是诚实，做了就做了，没做就没做）。
1.5. 给Windows程序猿的提示
    作者在这扯了一大堆，但他主要想表达几个观点。
    1.他对Windows不感冒；
    2.他不推荐使用Windows；
    3.他鼓励大家使用Linux，BSD或者其他的Unix来代替Windows。
    但是有句话叫萝卜白菜各有所爱，如果你非要使用Windows，你将会很乐意了解到如下一些知识信息。
    Cygwin，简单说，它是一组Unix工具套件，工作在Windows上，可以通过安装Cygwin来达到在Windows下使用Unix环境的目的。据小道消息，使用Cygwin就可以编译本书中的代码，而不用对它们做修改。（很明显，作者连Solaris都没有，更不会有Windows了，所以他应该也没Cygwin，所以自然只能是靠小道消息来验证了。我有Windows，我使用Cygwin，我告诉你这条小道消息是真的！）
    如果非要使用纯粹的Windows环境来编译本书中的代码，读者需要做的工作如下所示：
    首先要添加 #include <winsock.h>。切记，在调用任何socket库之前，需要先调用WSAStartup()函数，给出一个示例代码：
    #include <winsock.h>
    {
        WSADATA wsaData;   // 如果这行不起作用
        //WSAData wsaData; // 那么就试试用这行

        // MAKEWORD(1, 1)使用Winsock1.1版, MAKEWORD(2, 0)使用Winsock2.0版:

        if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0) {
            fprintf(stderr, "WSAStartup failed.\n");
            exit(1);
        }
    }
    （我看到这里也不得不说，还是用Linux-like的系统比较好）
    在链接阶段，得指定编译套件去链接Winsock的库，一般都是调用wsock32.lib或者winsock32.lib，如果是Winsock2.0版，就调用ws2_32.lib。在VC++集成开发环境中，这些指定库的操作可以这样完成：Project菜单 --> Settings --> Link --> 找到“Object/library modules”。然后把“wsock32.lib”添加到那张表里头。
    最后当你再也不用sockets库时，需要调用WSACleanup()函数，具体细节请使用在线帮助手册吧。（我估计作者是编不下去了...）
    一旦把上面这些做好了，本教程中大部分示例代码应该都可以适用于Windows了，但是也有些例外。比如说这个，你不要使用close()函数来关闭一个socket，这里你需要使用closesocket()函数来代替close()函数。另外select()函数只能用于socket描述符，而不能用于文件描述符（file descriptors），比如文件描述符0是代表stdin，标准输入。
    想要知道更多关于Winsock的信息，应该查阅Winsock的FAQ。
    我提供了四个FAQ的URL：
    1.http://www.linux.com/
    2.http://www.bsd.org/
    3.http://www.cygwin.com/
    4.http://tangentsoft.net/wskfaq/
    本书的许多示例代码中用到了fork()系统调用，但是很不幸的是Windows并没有。你可能不得不通过连接一个符合POSIX标准的库来使得fork()系统调用生效，或者你也可以用CreateProcess()来代替代码中出现的fork()。使用系统调用fork()时并不需要输入任何参数，但是CreateProcess()需要用48bililion的参数。如果你没有达到那样子，那么CreateThread()会更容易使用。呃...讨论多线程什么的话题，已经超出了本书的讨论范围。我只能说这么多了，你懂得！（意思说作者自嘲是Windows idiot吧）
1.6. 邮件政策
    大体上来说我我也很乐意帮助大家回答你们遇到的问题，所以欢迎来搞。但是我不能保证每一封信都会回答，毕竟我自己的生活也非常紧张忙碌，如果我真的没时间回答你，我通常就把那封信给删了，别误会，这并不是针对任何人，仅仅是因为我不能总是有时间对于你们的要求给出详细的答案。
    有个规则是，越复杂的问题，能得到我回应的可能性也越小。如果你能在提问之前精简你的问题，并且提供一些相关的信息（例如你使用的平台和编译套件、你得到的错误信息，任何你觉得会有助于解决问题的信息），那么你将会大大的增加得到回应的可能性。建议你读一读ESR的书吧，《How To Ask Question The Smart Way》，在http://www.catb.org/~esr/faqs/smart-questions.html。它会告诉你如果更聪明的提问。
1.7. 申请镜像
    如果你要给这个网站做镜像，我非常欢迎，不管是公共的镜像还是私有镜像。如果你愿意做一个公共镜像，并且想让我把它放置到本站主页上，请来信，地址是：beej@beej.us。
1.8. 给译者的提示
    （这一段貌似是给我看的）
    如果你想要把这本书翻译成其他语言，请写信给我，邮箱就用上面那个。我会把你的翻译版本放在我的主页上面。请译者们尽管放心的在翻译版本里面加上你的名字和联系方式吧。
    （我本不打算加的，但是看到这句话，好吧。）
    y11022053@gmail.com，Michael，中国广东省。（有外企的同行在看嘛？能否内推一下我，呵呵）
    你也可以在自己的主页提供翻译版本的下载链接，我会把这个链接放在我的主页，其实不管是放你那或者放我这，都行！
    请注意接下来那一段中的有关许可证的限制条件的说明。
1.9. 版权和出版
    （此处省略一大堆，总而言之，你不能拿着作者的写的东西去出版卖钱，既不合法，也不合理。但是有一点，如果是为了教育，请放心拿着本书去印刷出版吧。唉，不得不感叹，国外只要涉及到教育，什么都好说。）

2. socket是什么？
    你总是听到别人谈论“sockets”，你可能在疑惑它们到底是什么东西。好吧，其实它们就是“一种使用标准Unix文件描述符来与其他程序通讯的方式”。
    呃...还是没听明白？
    好吧。我猜你可能听过一些著名Unix高手的一些名言锦句，例如Jeez的，“Unix下的每一个东西都是一个文件！”。他说的是事实，也就是说Unix程序进行任何类型的I/O操作，都是通过读和写文件描述符。简而言之，一个文件描述符就是一个整数，但是这个整数和一个已打开的文件关联起来了。但是关键点就在这里，这个所谓的文件可能是一个网络连接，一个FIFO，一个管道，一个终端，一个真正存于磁盘上的文件，亦或者任何类似于这样的其他东西。还是那句老话，Unix下的每一个东西都是一个文件！所以当你想要与其他程序通过Internet进行通讯的时候，你将要通过读写所谓的文件描述符来完成，可能暂时怀疑，不过你最好相信我。
    “从哪获取用来进行网络通讯的文件描述符呢？”，答案就是调用socket()这个系统调用。它会返回一个socket描述符，然后你就可以通过使用特定的socket调用——send()和recv()，在这个socket描述符上来进行通讯了。
    也许你有疑问了，如果说socket描述符也是一个文件描述符，那为什么我不能在这个socket描述符上使用平常用惯了的read()和write()函数来进行通讯呢？简单地说，你确实可以使用！但是有一点，对于你想传输的数据，send()和recv()提供更加强大的控制能力。
    下一步我想告诉你，根据你使用的不同Unix-like系统，它们各自拥有不同的种类的sockets。有DARPA Internet地址（Internet Sockets），本地节点上的路径名（地址）（Unix Sockets），CCITT X.25地址（X.25 Sockets）（这种其实可以忽略）。请一定要注意，本书所讨论的是第一种：Internet Sockets。
2.1. 两种不同类型的Internet Sockets
    什么？还有两种不同类型的Internet Sockets？是的，我没扯蛋。其实不止两种类型，还有更多，我只是不想吓到你，所以我在这儿只告诉你有两种类型的Internet Sockets。还有一点我想告诉你，“Raw Sockets”是非常强大的，你应该敬仰它们！
    好吧，不扯了。到底是Internet Sockets分为哪两种类型？
    第一种是，“Stream Sockets”；另一种是“Datagram Sockets”。在本书的后面可能会被分别援引为“SOCK_STREAM”和“SOCK_DGRAM”。
    用图来说明吧
    Sockets +-> Internet Sockets +-> Stream Sockets   <--> SOCK_STREAM
            +-> Unix Sockets     +-> Datagram Sockets <--> SOCK_DGRAM
            +-> X.25 Sockets
    Datagram Sockets有时被称作“无连接的sockets”。（尽管Datagram Sockets可以被connect()来连接，如果你真的想要这样做）
    Stream Sockets是可靠的、双向连接的通讯流。如果你按照顺序发送“1,2”出去，这些数据将会按照“1,2”这个顺序到达通讯的另一头。并且数据的内容也不会出错。
    哪些程序使用了Stream Sockets呢？你可能已经听说过telnet应用程序吧，它就是用了Stream Sockets。你输入的所有的字符都需要按照同样的顺序到达对方那边，不是嚒？不仅如此，web浏览器使用的HTTP协议，也是使用了Stream Sockets来获取页面。如果你用telnet远程连接到一个web网站的80端口，然后输入“GET / HTTP/ 1.0”，然后输入两次回车，对方真的会发送一个HTML页面过来给你哦！
    Stream Sockets是如何实现这种高级的数据传输质量的？原来它们使用一个叫做“The Transmission Control Protocol”的协议，就是TCP协议啦（可以参考一下RFC 793来获取更多关于TCP的详细信息，URL是：http://tools.ietf.org/html/rfc793）。TCP协议可以使得你的数据按序到达并且数据内容无错误。你可能之前听过“TCP/IP”，这里的TCP就是那个TCP，而后面的IP指代的是“Internet Protocol”（可以参考RFC 791来获取更多关于IP的详细信息，URL是：http://tools.ietf.org/html/rtf791）。IP协议主要是负责处理Internet路由工作，它并不保对数据完整性负责。
    （事实上TCP是基于IP的，IP负责控制数据怎么走才能到达目的地，TCP负责数据完整性和有序到达，具体可以参考TCP/IP详解这本书）
    Datagram Sockets是怎么样的呢？为什么它们被称为“无连接”呢？他们具体在干什么？为什么说他们不可靠？为了弄清楚这些问题，首先要知道这些事实：如果你使用Datagram Sockets来发送一个datagram，它仅仅是可能会到达另一端，但是它不一定按序到达。但有一点你不用担心，如果到达了另一头，这些数据包肯定是无错的。
    Datagram Sockets也是使用IP协议来完成路由工作的，但是Datagram Sockets并不是用TCP协议，它使用的是“The User Datagram Protocol”，也就是“UDP”协议（具体请参见RFC 768，URL是：http://tools.ietf.org/html/rfc768）。
    为什么说“无连接”呢？从根本上说，相对于Stream sockets而言，Datagram Sockets在通讯的时候并没有去维持一条已打开的连接。你做的只是建立一个数据包，往IP头部里面填上目的地信息，然后就发出去了，并不需要一个连接。普遍来说，他们应用于当TCP栈不可用时或者需要传输一些并不是一定要送达的包的时候。使用它的典型程序有：tftp（Trivial File Transfer Protocol，算是FTP的兄弟版），dhcpcd（一个DHCP的客户端程序），多人游戏，音频流，视频会议，等等。
    “呃，等等。我记得tftp和dhcpcd是可以被用于把二进制应用程序从一个主机传送到另一个主机上的！如果想要到达端的应用程序可以使用，那数据肯定不能丢失啊！这该怎么解释呢！”。
    好吧，真相就是：tftp程序及其类似的这种程序，它们虽然基于UDP协议，但是在上层还有自己的协议！举个例子，tftp协议中规定，接受者对于每一个接收到的包都必须做出回复，意思是说“我收到了！”（也叫“ACK”包）。如果原始发送者未得到回复，打个比方，发送完包后，五秒内还没得到接受者发来的ACK包，那发送者就会重新发送一次刚才拿个包，然后周而复始，直到发送者得到接受者发来的ACK包。当你去实现一个既可靠的又基于SOCK_DGRAM的socket的应用程序的时候，这种确认的方式就非常重要了。（作者的意思是tftp协议是基于UDP协议的，在tftp协议中来增加可靠的控制机制）
    像某些不需要可靠的连接的应用程序，例如说游戏或者音视频流媒体，直接可以忽略那些在传输过程中遗失的数据包，或者聪明的弥补这些数据包。（玩过《雷神之锤》（《Quake》）的玩家就知道这种影响的表现形式，用专业术语说就是丢包会造成“万恶的延迟”）（难道我会告诉你玩Dota也非常讨厌延迟吗？）
    那为什么会使用一个不可靠的基础协议呢？两个原因：第一个是想追求速度，第二个还是对速度的追求！这种发送后就不再管的方式比发送后全程跟踪并且保证安全、有序到达的方式更快。相对来说，如果你发送的内容是聊天的消息，那肯定用TCP更好；如果你发送的是关于所有玩家地理位置更新的信息，假设每秒要发送40个次，并且其中的一到两个数据包并不会带来太大的负面影响，那UDP当然是一个非常不错的选择。
2.2. 网络的原理以及一些胡扯
    自从我提到协议分层概念起，就应该来谈论一下网络到底是如何真正工作的这个话题了。我也会展示一些示例，比如SOCK_DGRAM包是如何被制造的。事实上，你其实可以跳过这一段，然而这一段却又能给你带来关于网络原理的背景知识。（我建议别跳过，学习某个东西，背景知识往往很重要，也就是“历史课”很重要，看这本书之前，你要是看过TCP/IP详解，将非常有利于吸收本书的精华！）
    |Ethernet{IP{UDP[TFTP(Data)]}}| ...
    图：数据的封装格式
    这里用TFTP程序产生的数据包来举例说明，上图是一个从Internet网络上抓到的数据包，从左到右，协议层级越来越高。
    所以说，了解一些数据包的封装形式非常非常重要，你没看过就真的不知道，哪怕只是瞄一眼，那理解起来就快多了。
    基本上来说是这样的：一旦某条要被发送的数据诞生了（你想给别人说“hello”），它就会被第一个协议（这里假设是TFTP协议）包裹了一个新的头部（很少有包裹到尾部），然后这一整个东西（TFTP头部+“hello”）将又会被下一个协议给包裹一个头部（比如说下一个是UDP协议，那么数据包就变成了（UDP头部+TFTP头部+“hello”），然后这一整个东西又要被下一个协议包裹一个头部（这里假设就是IP协议），那数据包现在就成了（IP头部+UDP头部+TFTP头部+“hello”），最终这坨东西被硬件设备（例如：物理网卡）包裹一个Ethernet头部，接着才会被放在网络上传输。最终形式是这样：[Ethernet头部 + IP头部 + UDP头部 + TFTP头部 + “hello”]。
    当另一端的主机接收到这个数据包时，一开始是硬件设备（例如也是物理网卡）先剥离Ethernet头部交给内核，然后内核按顺序分别剥离IP头部和UDP头部，交给TFTP程序（一般是一个进程），接着TFTP程序剥离TFTP头部后就得到了最开始对面想传送的消息“hello”。（作者这里说得非常透彻，IP和UDP是在运行在内核中的，最后才把纯粹的数据交给应用层）
    有了上面这些知识来做陪衬，我们终于可以开始引入被很多人喷的网络分层模型（Layered Network Model，也叫做“ISO/OSI”）。这个网络模型描述了一个功能完整的网络系统，相对其他网络模型来说，这个模型有很多功能性优点。打个比方，通过这个模型，你可以在不用关心数据在物理上究竟是如何被传输的前提下来编写sockets应用程序。在物理上，数据可能是通过串口传输，或者AUI传输，这些都你可以不用关心，因为这套系统的底层协议会为你做这些。事实上，真实的网络拓扑结构对于使用socket的程序猿来说是透明的。（虽然说透明，但是最好是做到知其然且知其所以然，这样会更好！所以这也是本端存在的意义）
    话不多说，我接下来将向你展示整个模型的层次细节，为了网络课的考试，请记住这些：
    *Application  （应用层）
    *Presentation （表现层）
    *Session      （会话层）
    *Transport    （传输层）
    *Network      （网络层）
    *Data Link（数据链路层）
    *Physical     （物理层）
    这里说的物理层是硬件设备（串口，以太网卡，等等）。而应用层离物理层的距离你可以试着想象一下，所谓的应用层就是用户和网络交互的那个地方。
    现在来说，这个网络模型已经发展得非常庞大了，你可以把它当成《汽车维修指南》来使用（大概可能是太庞大，太复杂以至于不太好用，我也不知道在外国人眼里《汽车维修指南》有什么潜在意思）。
    对于Unix系统来说，其实存在一个始终如一的网络模型，它也是分层式的。
    *Application Layer           （应用层）     （telnet，ftp，等等）
    *Host-to-Host Transport Layer（端到端传输层）（TCP协议和UDP协议）
    *Internet Layer              （Internet层） （IP协议和路由方式）
    *Network Access Layer        （网络接入层）  （以太网，wi-fi网或者其他）
    在目前的情况下，你几乎可以看到这些逻辑层和原始数据的封装步骤之间的对应关系了。
    想知道要封装一个简单的数据包要做多少工作吗？呃，看起来你不得不使用cat命令来查看这些数据的头部里面到底写着什么了。当然，我是开玩笑的。对于stream sockets来说，其实你所需要做的全部工作仅仅是调用send()把数据传出去而已。对于datagram sockets来说，也只需要调用sendto()而已。内核已经帮你构建好了传输层和Internet层，硬件设备也已经构建好了网络接入层。现代科技啊！碉堡了！
    结束我们对于网络原理的窥见吧。呃，我好像忘记告诉你关于路由的事情了。好吧，路由其实就是——呃，我其实根本没打算讨论它。路由器会查看下层协议传上来的每一个数据包的IP头部，然后查询路由表，然后就...呃，你要真的关心这些细节，那就查阅IP协议的RFC文档吧（URL是：http://tools.ietf.org/html/rtf791）。你根本不会去学习IP协议？呵呵，你不还是好好的活着嘛！（最好是阅读本书中提到的RFC文档，尽管枯燥，可能还是英文的，但是我保证，读完肯定不后悔）

3. IP地址，结构体以及数据再加工
    我们将要做点儿改变了，要开始谈论一些代码了。（之前说了这么多，并没有设计如何编程，纯理论而已）
    但是一开始呢我还是先别谈代码。首先，我想稍微对IP地址和端口进行一下讨论，以至于我们可以有点儿概念。然后我们将讨论sockets的API，关于它们如何存储和操作IP地址和其他一些数据。
    3.1. IP地址，IPv4和IPv6
    很久很久以前，那时候Ben Kenobi仍然被称作Obi Wan Kenobi，当时存在一个叫做Internet Protocol Version 4的网络和路由系统（因为IP协议就是干网络和路由的工作的），简称IPv4。它其中定义了一种由4个字节组成的地址（这也是这个地址被称作“IP地址”的原因了，因为在IP协议里面定义的），通常被写成“点分十进制”样式，例如：192.0.2.111。
    你应该在很多地方都看到过它了。
    事实上，所有的Internet上的网站都是使用IPv4。
    那时候大家使用IPv4，都用得很爽。直到有一天，有部分人，比如说Vint Cerf（详见http://en.wikipedia.org/wiki/Vinto_Cerf）给所有人发出了一个警告：IPv4的地址就快被我们用完了！！
    （同时也启示了大家，IPv4的繁荣昌盛和末日到来），Vint Cerf也被认为是Internet之父！所以我毫不怀疑他的断言！
    IP地址即将被用完？怎么可能啊？我想说，起码有几十亿个IP地址啊（4个字节），未必这世上真有数十亿台主机？
    呃，真的有这么多！！！
    其实在最开始的时候，只有少数几台主机而已，那时候大家都认为数十亿是一个不可思议的大数字，一些大型组织机构曾经非常慷慨的分配过上百万个IP地址来给他们自己使用。（例如：Xerox，MIT，Ford，HP，IBM，GE，AT&T，以及一些稍小的公司，比如苹果公司（呃，苹果现在可不是所谓的小公司了））
    如果不是当意识到这个危机后，采取了一些措施手段来遏制，我们可能早就把IPv4地址用光了，但那也只是权宜之计。
    但是到了现在，我们生活在一个几乎每样东西都拥有IP地址的时代，每一台电脑，每一台计算器，每一台手机，甚至是我家的狗，等等。
    正是由于这种原因，IPv6诞生了。为了不让使用下一个IP协议版本的人再次抱怨“我早就告诉过你，多弄点儿地址！”诸如此类的，于是乎，IP协议的下一个进化版本就必须拥有足够多的IP地址。虽然Vint Cerf的肉体已经死亡，但是他的思想将永垂不朽，其实他可能已经存在于某些高智能程序中了，例如ELIZA（详见http://en.wikipedia.org/wiki/ELIZA）。
    我不知道我说的这些给了你什么启示。
    至少，我们需要更多的地址。不仅仅是两倍于IPv4而已，也不仅仅是数十亿倍而已，最终的结果是2的128次方个理论上的IP地址。
    你可能会问，“Beej，你没忽悠我吧？我有各种原因来拒绝相信这么大的数字。”好吧，你可能认为32位和128位之间的差距听起来没有多大，只是相差96位而已，是嚒？但是你想想，32位就可以代表4百亿个（2的32次方），那128位就是（2的128次方啊，那得多大啊，天呐）。几乎可以代表整个宇宙间的星星了。
    请忘记之前说过的IPv4地址的“点分十进制”书写格式法吧，现在我们有了一种新的写法，叫“十六进制表示法”（我也不知道如何翻译更准确），就是每两个字节之间用英文冒号隔开，你懂得，一个字节有由两个十六进制数表示，像这样：
2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551。
    如果你碰到某个IP地址，它其中包含很多零，你可以把它缩起来写，高位的0可以不写，并且两个冒号全是零，那你就别写了，举个例子吧：
2001:0db8:c9d2:0012:0000:0000:0000:0051 <-> 2001:db8:c9d2:12::51
2001:0db8:ab00:0000:0000:0000:0000:0000 <-> 2001:db8:ab00::
0000:0000:0000:0000:0000:0000:0000:0001 <-> ::1
    这几个例子中的IPv6地址是是两者互相等价的。
    IPv6地址::1是环回地址，跟IPv4中的127.0.0.1是一个意思，都表示“这个主机正在良好运行IP协议”。
    最后，你可能会想到，应该要有一种兼容IPv4地址的IPv6地址（大部分协议、标准、架构都遵循向前兼容的准则，通俗点儿说就是新版本一定要兼容老版本），如果你愿意，可以这样来做，以至于达到兼容IPv4地址的目的。比如IPv4地址：192.0.2.33，在IPv6地址里面表示为：::ffff:192.0.2.33，公式大概就是IPv6 <-> ::ffff:IPv4。
    3.1.1. 子网
    因为一些组织的原因，大部分时候为了简便，经常把从IP地质第一位开始，到某一位打止，这一段位数称为IP地址的网络部分，而剩下的就被认为是主机部分。
    举例说明，在IPv4中，假设你有一个IP地址：192.0.2.12，你可以假设前三块（就是192.0.2）是网络部分，最后一块是主机部分。换句话说，这个IP地址就代表在192.0.2.0的网络中的第12号主机了。
    说点对于现在来说算是有点儿过时的知识吧。准备好了吗？开始了！很久以前，那会儿子网是分类的，而不是想今天这样，想用几位作为网络部分，就可以用几位。那会儿是以第一块，第二块和第三块分别分成三类，作为网络部分的。那相应的，主机部分就分别对应，拥有后三段，后两段和后一段。如果运气好，能拥有一个只适用第一块作为网络部分的网络地址，那么就意味着，你拥有24位的主机部分了。这种网络被称为A类地址网络。相应的就有B类、C类了。（这三类地址的网络拥有的主机数量一般要减去2，因为最小和最大一般都是保留的）
    现在你应该就明白了，A类地址的网络数量不多，B类地址的网络数量更多，C类地址的网络数量非常多。
    IP地址的网络部分是依靠一个叫做“子网掩码”的数字来描述的，子网掩码就是一长串连续的数字1，数字1的个数就是子网掩码的长度。把当前的IP地址和子网掩码做“按位与”操作，结果就是当前的网络部分了，也叫网段，显然，剩下的就是你在当前网段的主机号了。举个例子：假设有个“255.255.255.0”的子网掩码，展开就是“11111111.11111111.11111111.00000000”，再假设你当前的IP地址是“192.0.2.12”，那么把这两者按位与，结果就是“192.0.2.0”，你所在的网段就是“192.0.2.0”，你的主机号就是12。
    不幸的是上述这种方案对于最终Internet的需求却满足不了。C类网络其实非常容易被用完，更不用问，最终A类网络也会被用完的。请注意，子网掩码的长度是可以任意的（当然得在32以内啊，IPv4地址的总长度才32），不局限于8、16、24位。举例来说，子网掩码还可以是这样的“255.255.255.252”，这是一个30位长的网络，余下的2位作为主机部分，也就是只能供4台主机使用，00,01,10,11。（一定要记得，子网掩码是一串连续的数字1，后面跟着一串连续的数字0，不能是这样“111110100000000...”）
    





















